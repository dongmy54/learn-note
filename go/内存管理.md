## 内存管理
### 1. 简介
程序要运行，离不开内存的分配；内存作为计算机中稀缺资源，内存管理的好坏直接决定程序的优劣。
在编程语言中内存的管理分为两类：
1. 程序员手动管理（诸如C、C++）
2. 由编程语言自己管理（比如，python、ruby、go等）

我们总是希望程序能够占用尽量少的内存，实现尽量高的性能；因此无论是操作系统层面，还是编程语言层面都做了许多的努力。

当然go语言为了实现这个目标，对内存的使用和回收，也是精打细算，做了很多优化，下面我们一起来看看。

### 2. 程序内存该如何分配才好？
假设我们是一门程序语言的实现者，要实现一个高性能的内存管理语言，我们不禁要问，什么样的内存分配才是好的分配？

首先，内存的申请需要通过操作系统的系统调用实现，而系统调用是有开销的；如果我们每次需要用一点内存，都去通过操作系统系统调用，那么开销可想而知，因此我们不希望频繁的向操作系统申请内存，最好一次申请一大块。

另外，进程拿到一大块内存后,是交给多个线程使用的，也就是都有使用权，在某一个时刻线程A和线程B都需要内存，为了避免他们拿到同一个内存地址，那么此时需要对整块内存加锁。

有了竞争，然后有了锁，既然有锁那么就有开销,我们该如何减少锁的开销呢？

您可以继续思考下去...

经过前面的思考，相信你已经对内存的分配有了一个感官的认识，下面我们看看go是怎么做的。

### 3. go内存分配框架
go的内存管理是基于**TCMalloc**(Thread Cache Malloc)核心思想实现的,那什么是TCMalloc呢？

每个线程会维护一个线程内存缓存（ThreadCache），从而减少直接向上层（CentralCache）获取时的锁竞争,每个线程需要内存时优先从线程缓存中获取,由于ThreadCache是每个线程独享的，此时无需加锁；如果ThreadCahe不足，则会从CentralCache获取,centralCache是所有缓存共享的，因此此时需要加锁。

### 4. 细看mspan

### 5. 总结


