##### 事务
> 1. 将多个命令打包，然后依次按顺序执行，执行过程中不会插入其它命令；
> 2. 本质就是将多个命令捆绑一起执行，主要用于命令间有关联的情况
PS: 事务执行后，会将多个命令的执行结果一起返回

###### 是否是原子操作？与传统关系性数据库事务区别
> 1. 首先它是非原子性的,传统关系性数据库，要求多个数据处理操作，要么全部不执行，要么全部执行
> 2. 如果事务中存在语法错误，则全部不执行
> 3. 如果事务执行过程中产生错误，那么产生的错误不执行，其它命令仍然正常执行

###### 原理
> 在实现层，它是将我们的多个命令缓存到一个队列中，在真正执行的时候，然后依次从队列中取出依次执行（中途不会插入其它命令）

###### 具体使用
> 一般使用的时候，会搭配多个命令一起使用
> - multi - 开启事务
> - exec - 执行事务
> - discard - 丢失事务
> - watch - 监控某个key，如果在事务执行前,key被修改，那么事务(包括里面所有命令)不会执行


简单实用
```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set age 15
QUEUED
127.0.0.1:6379> set new_age 34
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
```

配合watch使用
```shell
127.0.0.1:6379> watch age
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set age 15
QUEUED
127.0.0.1:6379> set new_age 34
QUEUED
127.0.0.1:6379> exec
(nil)   这里由于age在exec之前改动了 所以事务执行不成功
```

中途丢弃事务
```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set age 15
QUEUED
127.0.0.1:6379> discard
OK
```

去掉监控
```shell
127.0.0.1:6379> watch age
OK
127.0.0.1:6379> unwatch
OK
```

ruby中使用
```ruby
$redis.multi do |transaction|
  transaction.set "foo", "bar"
  transaction.incr "baz"
end
```

