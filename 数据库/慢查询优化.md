#### 概述
在真实场景中性能优化有多方式，比如：从硬件层面提高机器配置、调整数据库配置参数等等；但是最简单、成本最低的优化方式莫过于sql优化，因此**这里主要讨论sql优化**；

一般而言，查询速度慢大多由于没有索引导致的，但是现实情况，是许多时候我们明明创建了索引，缺没有用到，因此我们需要知道索引失效的场景

#### 索引失效的场景?
```sql
// 1. 索引字段类型和sql语句使用字段类型不同
// 假设这里phone_num 是 string 类型
select * from users where phone_num = 18200456787;

// 2. 字段使用函数/运算/类型转换

// 3. 不符合最左匹配原则
// 假设 组合索引为 city name age
select * from users where name = 'zhangsan' and age = 23;

// 4. like模糊匹配 %位于最左边
select * from users where email like "%43@qq.com";

// 5. or语句前后使用了非索引列
// 假设name有索引 age无索引
select * from users where name = 'zhangsan' or age = 18;

// 6. 组合索引当中存在范围查找时，会导致右侧的字段索引失效
// 假设这里 city,age,name为组合索引 只会用到city age name用不上 
select * from users where city = '张三' and age > 20 and name = '张三';

// 7. != 单列索引时候
// 假设存在单列索引age;ps:如果存在组合索引经测试会用上
select * from users where age != 26;
```

##### sql执行计划查看
```sql 
mysql> explain select * from users1 where age = 28;
+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | users1 | NULL       | ref  | idx_age       | idx_age | 5       | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

// 具体字段含义
id: 一个select 对应一个id
select_type: select 关键字对应的查询类型
type: 针对单表访问方法（重要）
possible_keys: 可能用到的索引（重要）
key: 实际使用索引（重要）
key_len: 用到的索引长度,越长越好主要是组合索引（重要）
ref: 索引比较的字段
rows: 预计读取行数，越少越好(重要)
filtered: 过滤后剩余行数占比
extra: 额外信息

// type比较(优->差)
system > const > eq_ref > ref > fulltext > req_or_null > index_merge > uniqe_subquery > index_subquery > range > index > all

const：主键 比如:id,或者唯一索引
eq_ref: 表之间joins通过主键/唯一索引
ref: 普通索引
req_or_null: 普通索引可能有null（比如：name = 'a' or name is null）
index_merge: 可能是索引1、索引2多个索引同时用到的情况
uniqe_subquery: 子查询（用到主键/唯一索引）
index_subquery: 自查询（普通索引）
range: 索引获取某些范围区间（比如: a > 10; 
// select * from users where id in (1,2,3,4);
index: 覆盖索引，选择其中的一个字段
// select key1 from table1 where key2 = 'q'; 假设存在key1 key2 key3组合索引
ALL： 全表扫描

PS：explain format=json 能展示更详细信息，推荐使用
```


