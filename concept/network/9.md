##### 包
> 1. 网路中跑的包都是有id的
> 2. 客户端 和 服务端都会缓存包的接收、发送情况
> 3. 累积确认：接收端如果确认了6，则代表1、2、3、4、5号包也收到了


##### 流量控制
> 1. 针对的是端到端
> 2. 取决于接收端的接收能了


##### 发送/接收端包状态
```ruby
# 发送端
已发送、已确认         - 已发送、未确认 - 准备发送 - 暂时不准备发送

# 接收端
已接收、应用程序还未读取 - 下次准备接收  - 暂时无法接收
```


##### 窗口大小
> 1. 接收端 会向 发送端发送自己能接受的窗口大小
> 2. 对发送端: window = 已发送、未确认 + 准备发送
> 3. 对接收端：window = 最大缓存接收 - 下次准备接收起点
> 4. 窗口大小并非是固定的，接收端可以实时调整
> 5. 当窗口大小为0时,发送端会发送窗口探测数据包
> 6. 为避免刚腾出来窗格立马被占满，接收端会等窗口大小达到一定的程度，才去更新窗口大小


##### 流量控制产生的问题
> 主要有两个：a、包达到的顺序会乱；b、会丢包


##### 办法
一：超时重传
> 1. 当包在一定的时间内没有到达,则会重传数据包
> 2. 如果一个包多次超时，下次重传的时间会加倍


二：快速重传(不用等到超时)
> 1. 利用ack的冗余参数，接收端连续三次收到，则表明包走丢了，自动重传
> 2. 利用TCP头里的SNACK(Selective Acknowledgment)



