#### http 

##### 一个完整请求过程
```ruby
1. 域名通过DNS解析成ip地址

2. 发送HTTP请求
a.请求行
b.首部
c.实体

3. TCP层将请求拆分成一个个报文，填上源ip地址、目标ip地址

4. IP层填上（目标/网关）MAC地址
判断：目标ip 是否和 自己 属于同一局域网
是：发送ARP协议，找到目标ip MAC地址
否：发送ARP协议，找到网关MAC地址

5. 网关取出ip地址,根据路由表查出下一跳路由，获取下一跳路由Mac，填上发出
在路由器之间层层转发，达到最后一跳路由器（发现目标ip是自己局域网的一个出口ip）
ARP协议找到目标ip Mac地址，然后发出

6. 目标机器
a.发现MAC地址符合
b.发现IP地址符合
c.根据ip头协议项，知道是TCP协议，解析TCP
d.根据包序列号，判断这个包是否是自己需要的，如果是放入缓存，并返回ACK,否则丢弃
e.根据端口号，交给HTTP服务器进程

7. 发送http响应 （HTPP服务器进程拿到,返回内容）
a. 状态行
b. 首部
c. 实体

8. 然后TCP拆分成报文，走一遍来时的路程
```

##### 请求头
> - `Content-Type` 正文类型
> - `Cache-Control: max-age=0` 根据max-age值做判断，如果缓存中值小于这个值，则用缓存
> - `If-Modified-Since` 如果服务器资源没有更新，返回`304 Not Modified`,用浏览器缓存


##### HTTP 2.0
> 1. 解决了队首阻塞问题，可以并行发送/响应请求
> 2. 减轻了服务器维护多个TCP时的性能损耗

一、压缩了首部
> http 1.1 在发送请求时，每次都会完整的发送所有头，而2.0在客户端-服务端维护一个头索引表，发送的时候只发送索引

二、将TCP拆分成多个流
> 每个流都有一个ID,流之间有优先级（PS：这里多个流之间有关联）

三、将消息拆分成更小的帧
> 多个数据帧属于同一个流

##### google QUIC协议
一、自定义连接
> 不以（源ip地址、源端口、目标ip地址、目标端口）做为ID标识，以随机64位数做为ID标识

二、自定义重传
> 1. 序号递增(相同包内容序号也不同)
> 2. 添加offset(利用offset组装内容)
> 3. RTT计算更加准确

三、无阻塞多路复用
> 流之间没有依赖关联，不会阻塞

四、自定义流量控制
> 以最大 offset 做计算，窗口大小计算更加准确


