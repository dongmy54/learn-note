# 块的本质：
# 1、打包代码，以后执行
# 2、作为函数变量（可赋值 可传方法）
# PS: 块不是对象


#===================================================================================#
# 定义块有两种基本方式
1、do .. end 或 
2、{ }


#===================================================================================#
# 定义块时 一般而言块的参数都是在{} /  do .. end ||中写
block1 = lambda {|a,b| p a,b }
block2 = lambda do |a,b|
          p a,b
         end

block1.call(1,2)    # => 1,2
block2.call(1,2)    # => 1,2


#===================================================================================#
# 创建 代码块对象 几种方法
object1 = Proc.new { |x| puts x + 1 }
object2 = proc { |x| puts x + 1 }
object3 = lambda { |x| puts x +1 }
object4 = ->(x) { puts x + 1 }  # -> 传递参数在{}外面
#object4 = -> { |x| puts x + 1}  PS: 不能这样写 

object1.call(2) # => 3
object2.call(2) # => 3
object3.call(2) # => 3
object4.call(2) # => 3


#===================================================================================#
# 块 传递 单层方法
# 1、方法中都不需 定义块参数
# 2、呼叫块 直接 yield
def m(x) 
  yield(x) 
end

m(3) { |x| puts "x = #{x}"}
# => x = 3


#===================================================================================#
# 块 传递 多层方法
def m1(x)
  yield(x)
end

def m2(x,&block_object) # 传递多层时 须定义 块参数
  m1(x,&block_object)
end

m2(3) {|x| puts "x + #{x}"}
# => x + 3


#===================================================================================#
# 对象 与 块
# 只有块才能传递
# 对象只能执行
block_object = lambda {|x,y| puts "x: #{x}; y: #{y}"} # 对象

def m1(a,b)
  yield(a,b)
end

m1(1,2,&block_object) # &block_object 是 块（+ &符号）
# => x: 1; y: 2

def m2(&block_object)
  block_object        # 去掉& 变成 对象
end

m2(&block_object).call(2,3) # m2(&block_object) 后得到对象
# => x: 2; y: 3 



