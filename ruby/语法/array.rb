# unshift 向数组前插值
[2,3,5].unshift(6)
# => [
#        [0] 6,
#        [1] 2,
#        [2] 3,
#        [3] 5
#    ]


#===================================================================================#
# 产生数组
# 1、（）中个数
# 2、 块中每个元素
Array.new(5){ rand(100) }
# => [
#        [0] 54,
#        [1] 55,
#        [2] 48,
#        [3] 71,
#        [4] 67
#    ]


#===================================================================================#
# select 做筛选
h = [{:a => 'A', :b => 'd'},
     {:a => 'w', :b => 'r'},
     {:a => 'w', :b => 't'}]

a = h.select{|x| x[:a] == 'A'}
# =>   [
#          [0] {
#              :a => "A",
#              :b => "d"
#          }
#      ]


#===================================================================================#
# reject delete_if 删除数组中某些元素
# 等价
Array(1..10).reject {|i| i % 3 == 0}
Array(1..10).delete_if {|i| i % 3 == 0}
# => [
#        [0] 1,
#        [1] 2,
#        [2] 4,
#        [3] 5,
#        [4] 7,
#        [5] 8,
#        [6] 10
#    ]


#===================================================================================#
# 测试一个
a = [1,2,3,4,5,6]
a.join('q')       # 1q2q3q4q5q6


#===================================================================================#
# 用*展开数组 赋值
arr = [2,5,8]
a,b,c = *arr  # * 展开数组
[a,b,c].each {|i| puts i}
# => 2
# => 5
# => 8


#===================================================================================#
# inject 与 reduce
# 相同的两个方法
# 功能：迭代效果（将上一次执行结果用于下一次）
# 1、在不传参数（初始值）时，第一个元素做初始值
# 2、这里n 初始值 m 执行后的结果
puts [1,2,3].inject {|n,m| m + n }    # => 6
puts [1,2,3].reduce {|n,m| m + n }    # => 6
puts [1,2,3].inject(2) {|n,m| m + n } # => 8


#===================================================================================#
# flatten 摊平数组
# 接参数时 表示摊平层级
arr = [1,2,3,[2,[5,6],3],8]
arr.flatten
# => [1,2,3,2,5,6,3,8]
arr.flatten(1)
# => [1,2,3,2,[5,6],3,8]



