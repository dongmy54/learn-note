#===================================================================================#
# 连等赋值
a = b = c = d = 'qwe' # a b c d 都等于 'qwe'


#===================================================================================#
# 三元运算符 可 多行
str = 
      false ?
      "真值" : "假值"
# => "假值"


#===================================================================================#
# 判断一个对象的类 是否 是xx?
"sadf".is_a?(String)  # => true
123.is_a?(Array)      # => false


#===================================================================================#
# 转字符串 为 常量
Hu = {:a => 2,:b => 'sd'}
h = 'H'
Kernel.const_get("#{h}u")[:a]
# => 2


#===================================================================================#
# 利用救援处理  单行异常
b = a rescue nil
# b 会 为nil


#===================================================================================#
# ensure 确保一定会执行
# PS: 可以把无论什么情况下 一定要执行的逻辑放进去
def test
  puts '做一些事...'
ensure              
  puts 'xx事情已做完'    # 无论如何（即使前面发生了异常）都会执行（但不做为返回值）
end

test
# 做一些事...
# xx事情已做完


#===================================================================================#
# 产生不重复随机字符串
arr = ('A'..'Z').to_a

current_own_values = ["ABCDE"]
is_same = true

while is_same
  temp_value = Array.new(5){ arr[rand(26)] }.join('')  # 将随机值串起来
  is_same = current_own_values.include?(temp_value)    # 判断是否相同
end

current_own_values << temp_value
# =>    [
#           [0] "ABCDE",
#           [1] "CCEOH"
#       ]


#===================================================================================#
# 函数限制次数 自我调用
def m(x,limit = 6)
  raise ArgumentError,'调用次数太多' if limit == 1
  
  return puts x*2 if x % 3 == 2
  m(rand(1000),limit -1)    # 自我调用 次数 -1
end

m(258)
# => 604


#===================================================================================#
# 迭代器简便写法 带参
class Numeric
  def add_a_value(b)
    puts b + self
  end
end

b = 3
(1..10).each(&b.method(:add_a_value))
# 4
# 5
# 6
# 7
# 8
# 9
# 10
# 11
# 12
# 13
# => 1..10


#===================================================================================#
# map 中; 条目
# 原结构不变，对结构中数据做处理后返回
def process(hash)
  hash[:a] += 3
end

result = [{a: 2},
          {a:4},
          {a: 5}].map {|item| process(item); item}

puts result.inspect
# [{:a=>5}, {:a=>7}, {:a=>8}]




