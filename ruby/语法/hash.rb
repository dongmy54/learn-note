# merge hash 合并
# 相同的键 将会被后面的键值 覆盖
h1 = {:a => 'ab',:b => 'df'}
h2 = {:a => 'we',:c => 's'}
h1.merge(h2)
# {
#     :a => "we",
#     :b => "df",
#     :c => "s"
# }


#===================================================================================#
# key(value) 查值的键
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.key('def')
# => :b


#===================================================================================#
# 取出 每个键
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.each_key {|k| puts k}
# a
# b
# c


#===================================================================================#
# 取出 每个值
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.each_value {|v| puts v}
# abc
# def
# kio


#===================================================================================#
# has_key? 是否有某键
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.has_key?(:b)
# => true
h.has_key?(:d)
# => false


#===================================================================================#
# hash_value? 是否有某值
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.has_value?('abc')
# => true
h.has_value?('k')
# => false


#===================================================================================#
# 取 hash 中所有键
h = {:a => 1,:b => 2}
h.keys
# => [:a,:b]


#===================================================================================#
# 取 hash 中所有值
h = {:a => 1,:b => 2}
h.values
# => [1,2]


#===================================================================================#
# 反转 hash 的 键值对
# PS: 没有invert!方法 
h = {:a => 2,:b => 3}
h.invert
# => {
# =>     2 => :a,
# =>     3 => :b
# => }


# to_a 转数组
# 实质上是 转二维数组
h1 = {:a => 1,:b => 2}
h1.to_a
# => [[:a,1],[:b,2]]
h2 = {:a => 3,:b => {:c => 'q',:d => 'qw'}}
h2.to_a
# => [[:a,3],[:b,{:c => 'q',:d => 'qw'}]]


#===================================================================================#
# hash 后面接 key 输出value
{
  :a => 'A',
  :b => 'B'
  }[:a]   # => 'A'


#===================================================================================#
# hash 也可用map
# i[0] key i[1] value
{:a => 'b',:b => 'c',:c => 'd'}.map{|i| puts "#{i[0]},#{i[1]}"}
# a,b
# b,c
# c,d


#===================================================================================#
# fetch
# 从hash取一个没有的键时，可返回默认 或 块中值
h = {:a => 'A',:b => 'B'}
h.fetch(:z, 'd')
# => 'd'
h.fetch(:z) {|i| i.to_s }
# => 'z'


#===================================================================================#
# find/detect方法 返回满足条件的元素 find detect 等价
# 返回的是一个数组
h = {:'1' => 'g', :'2' => 'o', :'3' => 'p'}
k,v = h.find {|k,v| v == 'o'}
puts k,v
# :'2'
# 'o'


#===================================================================================#
# hash 过滤
# 返回的是hash
h = {:a => 1, 
     :b => 3,
     :c => 5, 
     :d => 9}

h.select {|k,_| h[k] > 3}
# => {:c=>5, :d=>9}


#===================================================================================#
# 嵌套hash 排序
# PS1: sort_by 利用（到达要排序的层）
# PS2: 结果回返回 数组
h = {:o => {:a => 1,:b => 'los'},
     :p => {:a => -2, :b => 'saf'},
     :k => {:a => 3, :b => 'fwe'},
     :l => {:a => 2, :b => 'sdd'}}

h.sort_by {|k,v| v[:a]}
# =>[[:p, {:a=>-2, :b=>"saf"}], 
# => [:o, {:a=>1, :b=>"los"}], 
# => [:l, {:a=>2, :b=>"sdd"}], 
# => [:k, {:a=>3, :b=>"fwe"}]]
