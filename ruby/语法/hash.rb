#===================================================================================#
# [] 取值
h = {:a => 'a', :b => 'b'}
puts h.[] :a
# a


#===================================================================================#
# fetch
# 从hash取一个没有的键时，可返回默认 或 块中值
h = {:a => 'A',:b => 'B'}
h.fetch(:z, 'd')
# => 'd'
h.fetch(:z) {|i| i.to_s }
# => 'z'


#===================================================================================#
# 取 hash 中所有键
h = {:a => 1,:b => 2}
h.keys
# => [:a,:b]


#===================================================================================#
# 取 hash 中所有值
h = {:a => 1,:b => 2}
h.values
# => [1,2]

#===================================================================================#
# values_at 从hash 中取 值的数组
# 键不存在 => [nil,nil]
h = {:a => 10,:b => 20,:c => 30}
puts h.values_at(:a,:b).inspect
# [10, 20]


#===================================================================================#
# each 同时取 键、值
h = {:a => 'ak',:b => 'bp'}
h.each {|k,v| puts "键#{k} = 值#{v}"}
# 键a = 值ak
# 键b = 值bp


#===================================================================================#
# 取出 每个键
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.each_key {|k| puts k}
# a
# b
# c


#===================================================================================#
# 取出 每个值
h = {:a => 'abc', :b => 'def',:c => 'kio'}
h.each_value {|v| puts v}
# abc
# def
# kio


#===================================================================================#
# 反转 hash 的 键值对
# PS: 没有invert!方法 
h = {:a => 2,:b => 3}
h.invert
# => {
# =>     2 => :a,
# =>     3 => :b
# => }


#===================================================================================#
# to_a 转数组
# 实质上是 转二维数组
h1 = {:a => 1,:b => 2}
h1.to_a
# => [[:a,1],[:b,2]]
h2 = {:a => 3,:b => {:c => 'q',:d => 'qw'}}
h2.to_a
# => [[:a,3],[:b,{:c => 'q',:d => 'qw'}]]


#===================================================================================#
# hash 中是否拥有 某键/某值
# key?    <=> has_key?
# value?  <=> has_value?
h = {:a => 'a',:b => 'b'}
puts h.key?(:a)          # true
puts h.has_key?(:a)      # true

puts h.value?('a')       # true
puts h.has_value?('a')   # true


#===================================================================================#
# key 从值 => 键
# 匹配 第一个符合的键
h = {:a => 10,:b => 25,:c =>10}
puts h.key(10)   # a


#===================================================================================#
# rassoc 从值 => 键
# 匹配 所有第一个满足条件 的键值对数组
h = {:a => 10,:b => 25,:c => 10}
puts h.rassoc(10).inspect
# [:a, 10]


#===================================================================================#
# hash 也可用map
# 键-值 => 数组 取出
# i[0] key i[1] value
{:a => 'b',:b => 'c',:c => 'd'}.map{|i| puts "#{i[0]},#{i[1]}"}
# a,b
# b,c
# c,d


#===================================================================================#
# find/detect方法 返回满足条件的元素 find detect 等价
# 返回的是一个数组
h = {:'1' => 'g', :'2' => 'o', :'3' => 'p'}
k,v = h.find {|k,v| v == 'o'}
puts k,v
# :'2'
# 'o'


#===================================================================================#
# hash 过滤
# 返回的是hash
h = {:a => 1, 
     :b => 3,
     :c => 5, 
     :d => 9}

h.select {|k,_| h[k] > 3}
# => {:c=>5, :d=>9}


#===================================================================================#
# delete_if VS reject!
# 1. 等价
# 2. 都返回剩余部分
h = {:a => 1, :b => 6, :c => 12}
return_h = h.delete_if{|_,v| v < 10}
puts h.inspect                 # {:c => 12}
puts return_h.inspect          # {:c => 12}

h = {:a => 1, :b => 6, :c => 12}
return_h = h.reject!{|_,v| v < 10}
puts h.inspect                 # {:c => 12}
puts return_h.inspect          # {:c => 12}



#===================================================================================#
# 嵌套hash 排序
# PS1: sort_by 利用（到达要排序的层）
# PS2: 结果回返回 数组
h = {:o => {:a => 1,:b => 'los'},
     :p => {:a => -2, :b => 'saf'},
     :k => {:a => 3, :b => 'fwe'},
     :l => {:a => 2, :b => 'sdd'}}

h.sort_by {|k,v| v[:a]}
# =>[[:p, {:a=>-2, :b=>"saf"}], 
# => [:o, {:a=>1, :b=>"los"}], 
# => [:l, {:a=>2, :b=>"sdd"}], 
# => [:k, {:a=>3, :b=>"fwe"}]]


#===================================================================================#
# transform_keys 转换 键
# 1、可接块
# 2、有 ! 方法
h = {:a => 100,:b => 200,:c => 300}
puts h.transform_keys(&:to_s)
# {"a"=>100, "b"=>200, "c"=>300}
puts h.transform_keys! {|k| k.to_s + 'dmy'}
# {"admy"=>100, "bdmy"=>200, "cdmy"=>300}
puts h
# {:a=>100, :b=>200, :c=>300}


#===================================================================================#
# tansform_values 转换 值
# 1、可接块
# 2、有 ！方法
h = {:a => 10,:b => 25,:c => 32}
puts h.transform_values(&:to_s)
# {:a=>"10", :b=>"25", :c=>"32"}
puts h.transform_values {|v| (v + 5).to_s}
# {:a=>"15", :b=>"30", :c=>"37"}
puts h
# {:a=>10, :b=>25, :c=>32}


#===================================================================================#
# slice 截取hash 片段
h = {:a => 10,:b => 20,:c => 30}
puts h.slice(:a,:c)
# {:a=>10, :c=>30}
puts h
# {:a => 10,:b => 20,:c => 30}


#===================================================================================#
# merge 合并 hash
# 1、默认情况下，同键 后者 会覆盖前者值
# 2、接块 自定义 值合并方式
# 3、有 merge! 方法
h1 = {:a => 10,:b => 20}
h2 = {:b => 25,:c => 30}
puts h1.merge(h2)
# {:a=>10, :b=>25, :c=>30}
puts h1.merge(h2) {|key,old_value,new_value| old_value + new_value}
# {:a=>10, :b=>45, :c=>30}
puts h1
# {:a=>10, :b=>20}